import{Q as b,V as k,X as x,Y as T,Z as D,$ as F,a0 as E,a1 as G,a2 as w,a3 as I,a4 as R,a5 as C,a6 as _,a7 as m,a8 as j,a9 as y,aa as L,ab as M,ac as v,ad as H,ae as U,af as B,ag as A,ah as z}from "./index-C2gQaTHI.js";function J(a){const{abi:r,data:t}=a,s=b(t,0,4),e=r.find(n=>n.type==="function"&&s===k(x(n)));if(!e)throw new T(s,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:e.name,args:"inputs"in e&&e.inputs&&e.inputs.length>0?D(e.inputs,b(t,4)):void 0}}const p="/docs/contract/encodeErrorResult";function O(a){const{abi:r,errorName:t,args:s}=a;let e=r[0];if(t){const d=F({abi:r,args:s,name:t});if(!d)throw new E(t,{docsPath:p});e=d}if(e.type!=="error")throw new E(void 0,{docsPath:p});const n=x(e),o=k(n);let c="0x";if(s&&s.length>0){if(!e.inputs)throw new G(e.name,{docsPath:p});c=w(e.inputs,s)}return I([o,c])}const h="/docs/contract/encodeFunctionResult";function Q(a){const{abi:r,functionName:t,result:s}=a;let e=r[0];if(t){const o=F({abi:r,name:t});if(!o)throw new R(t,{docsPath:h});e=o}if(e.type!=="function")throw new R(void 0,{docsPath:h});if(!e.outputs)throw new C(e.name,{docsPath:h});const n=(()=>{if(e.outputs.length===0)return[];if(e.outputs.length===1)return[s];if(Array.isArray(s))return s;throw new _(s)})();return w(e.outputs,n)}const P="x-batch-gateway:true";async function S(a){const{data:r,ccipRequest:t}=a,{args:[s]}=J({abi:m,data:r}),e=[],n=[];return await Promise.all(s.map(async(o, c)=>{try{n[c]=o.urls.includes(P)?await S({data:o.data,ccipRequest:t}):await t(o),e[c]=!1}catch(d){e[c]=!0,n[c]=V(d)}})),Q({abi:m,functionName:"query",result:[e,n]})}function V(a){return a.name==="HttpRequestError"&&a.status?O({abi:m,errorName:"HttpError",args:[a.status,a.shortMessage]}):O({abi:[j],errorName:"Error",args:["shortMessage"in a?a.shortMessage:a.message]})}class W extends y{constructor({callbackSelector:r,cause:t,data:s,extraData:e,sender:n,urls:o}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${L(c)}`)],`  Sender: ${n}`,`  Data: ${s}`,`  Callback selector: ${r}`,`  Extra data: ${e}`].flat(),name:"OffchainLookupError"})}}class X extends y{constructor({result:r,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${L(t)}`,`Response: ${M(r)}`],name:"OffchainLookupResponseMalformedError"})}}class Y extends y{constructor({sender:r,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${r}`],name:"OffchainLookupSenderMismatchError"})}}const Z="0x556f1830",N={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function K(a, {blockNumber:r,blockTag:t,data:s,to:e}){const{args:n}=v({data:s,abi:[N]}),[o,c,d,i,u]=n,{ccipRead:f}=a,g=f&&typeof f?.request=="function"?f.request:$;try{if(!H(e,o))throw new Y({sender:o,to:e});const l=c.includes(P)?await S({data:d,ccipRequest:g}):await g({data:d,sender:o,urls:c}),{data:q}=await U(a,{blockNumber:r,blockTag:t,data:B([i,w([{type:"bytes"},{type:"bytes"}],[l,u])]),to:e});return q}catch(l){throw new W({callbackSelector:i,cause:l,data:s,extraData:u,sender:o,urls:c})}}async function $({data:a,sender:r,urls:t}){let s=new Error("An unknown error occurred.");for(let e=0; e<t.length; e++){const n=t[e],o=n.includes("{data}")?"GET":"POST",c=o==="POST"?{data:a,sender:r}:void 0,d=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(n.replace("{sender}",r.toLowerCase()).replace("{data}",a),{body:JSON.stringify(c),headers:d,method:o});let u;if(i.headers.get("Content-Type")?.startsWith("application/json")?u=(await i.json()).data:u=await i.text(),!i.ok){s=new A({body:c,details:u?.error?M(u.error):i.statusText,headers:i.headers,status:i.status,url:n});continue}if(!z(u)){s=new X({result:u,url:n});continue}return u}catch(i){s=new A({body:c,details:i.message,url:n})}}throw s}const te=Object.freeze(Object.defineProperty({__proto__:null,ccipRequest:$,offchainLookup:K,offchainLookupAbiItem:N,offchainLookupSignature:Z},Symbol.toStringTag,{value:"Module"}));export{Q as a,N as b,$ as c,J as d,O as e,Z as f,te as g,P as l,K as o};
